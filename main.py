import numpy as np
import pandas as pd

mnist_mean = 0.1307
mnist_std = 0.3081


#gradient of image
def gradient(x, y):
    return np.random.rand(10)


#forward pass of model
def forward(x):
    return np.random.rand(10)


#train model on data
def trainModel(data):
    print("train model")

    return model


#test metrics of the classifier
def testClass(classifier, testData):
    print("metrics about classifier idk yet")
    return testData


#generate trained classifier on data on data classifiying as 0-6 based on class
def whatMethod(data):
    model = "trained model temp"
    return model


#generate trained classifier on data classifing as adversarial or not
def isAdversarial(data):
    model = "trained model temp"
    return model


#generate perturbed images based on model with random perturbation
def randun(data, model):
    return data


#generate perturbed images based on model with perturbation generated by targeted C&W algo
def cnwtar(data, model):
    return data


#generate perturbed images based on model with perturbation generated by targeted DeepFool algo
def dftar(data, model):
    return data


#generate perturbed images based on model with perturbation generated by untargeted DeepFool algo
def dfun(data, model):
    retData = data.copy()
    for i in range(len(data)):
        x = data.iloc[i,1:] 
        x = np.array(x) #image as numpy array
        x = x / 255
        x = ((x - mnist_mean) / mnist_std).reshape(1, -1) #normalize image
        y = data.iloc[i,0] #image label
        probabilities = forward(x) #get probabilities of image
        while(np.argmax(probabilities) == y):
            gradients = gradient(x, y) #get gradient of image
            perturbation = np.zeros(x.shape)
            min_perturbation = np.inf
            for i in range(10):
                perturbation = perturbation + (gradients[i] * gradients[i])
                perturbation = perturbation / np.linalg.norm(perturbation)
                perturbation = perturbation * 0.01
                perturbed_image = x + perturbation
                perturbed_image = np.clip(perturbed_image, 0, 1)
                perturbed_image = (perturbed_image*mnist_std) + mnist_mean
                perturbed_probabilities = forward(perturbed_image)
                perturbed_label = np.argmax(perturbed_probabilities)
                perturbed_probability = perturbed_probabilities[perturbed_label]
                if perturbed_label != y:
                    perturbation = perturbation * perturbed_probability
                    if np.linalg.norm(perturbation) < min_perturbation:
                        min_perturbation = np.linalg.norm(perturbation)
                        best_perturbation = perturbation
            x = x + best_perturbation
            probabilities = forward(x)
        x = (x*mnist_std) + mnist_mean #unnormalize image
        x = x * 255
        retData.loc[i] = np.append(y, x)
    return data


#generate perturbed images based on model with perturbation generated by targeted FGSM algo
def fgsmtar(data, model):
    retData = data.copy()
    for i in range(len(data)):
        x = data.iloc[i,1:] 
        x = np.array(x) #image as numpy array
        x = x / 255
        x = ((x - mnist_mean) / mnist_std).reshape(1, -1) #normalize image
        y = data.iloc[i,0] #image label
        probabilities = forward(x) #get probabilities of image
        epsilon = .005 #perturbation amount
        while(np.argmax(probabilities) != 0):
            gradients = gradient(x, 0) #get gradient of image
            x = np.clip((x - epsilon * np.sign(gradients)), 0 , 1)
            probabilities = forward(x)
        x = (x*mnist_std) + mnist_mean #unnormalize image
        x = x * 255
        retData.loc[i] = np.append(y, x)
    return retData


#generate perturbed images based on model with perturbation generated by untargeted FGSM algo
def fgsmun(data, model):
    retData = data.copy()
    for i in range(len(data)):
        x = data.iloc[i,1:] 
        x = np.array(x) #image as numpy array
        x = x / 255
        x = ((x - mnist_mean) / mnist_std).reshape(1, -1) #normalize image
        y = data.iloc[i,0] #image label
        probabilities = forward(x) #get probabilities of image
        epsilon = .005 #perturbation amount
        while(np.argmax(probabilities) == y):
            gradients = gradient(x, y) #get gradient of image
            x = x + epsilon * np.sign(gradients)
            probabilities = forward(x)
        x = (x*mnist_std) + mnist_mean #unnormalize image
        x = x * 255
        retData.loc[i] = np.append(y, x)
    return retData


def main():
    #read in data and label columns
    data = pd.read_csv("mnist_train.csv")
    columns = ['number_label'] + [f'pixel_{i}' for i in range(784)]
    data.columns = columns

    #train model on first 10000 images and where probabilities will be gotten from   
    model = trainModel(data[:10000])

    #generate adversarial images 400 each
    #for simplicity 0 is always the target class
    FGSMUntargeted = fgsmun(data[10000:10400], model)
    FGSMTargeted = fgsmtar(data[10400:10800], model)
    DeepFoolUntargeted = dfun(data[10800:11200], model)
    DeepFoolTargeted = dftar(data[11200:11600], model)
    CarliniWagnerTargeted = cnwtar(data[11600:12000], model)
    randUntargeted = randun(data[12000:12400], model)

    #make model, use model to generate adversaries, train classifier, test classifier, visualize

    #combine data to train classifier on 4000 true images and 400*6 adversarial images
    trainingData = pd.concat([data[12400:16400],FGSMUntargeted, FGSMTargeted, DeepFoolUntargeted, DeepFoolTargeted, CarliniWagnerTargeted, randUntargeted])
    
    #label training data as true or perturbed 0 is real 1 is perturbed
    tfValues = []
    for i in range(6400):
        if i < 4000:
            tfValues.append(0)
        else:
            tfValues.append(1)
    trainingData1 = trainingData.copy()
    trainingData1['True/Perturbed'] = tfValues

    #combine data to train classifier on 4000 true images and  1-6 for each class of adversarial images
    classValues = []
    for i in range(6400):
        if i < 4000:
            classValues.append(0)
        elif i < 4400:
            classValues.append(1)
        elif i < 4800:
            classValues.append(2)
        elif i < 5200:
            classValues.append(3)
        elif i < 5600:
            classValues.append(4)
        elif i < 6000:
            classValues.append(5)
        else:
            classValues.append(6)
    trainingData2 = trainingData.copy()
    trainingData2['Class'] = classValues

    # --------------------------- #
    # Training and implementation #
    # --------------------------- #
    classifier1 = isAdversarial(trainingData1)
    classifier2 = whatMethod(trainingData2)

    # ------- #
    # Testing #
    # ------- #

    #read in test data
    testData = pd.read_csv("mnist_test.csv")
    columns = ['number_label'] + [f'pixel_{i}' for i in range(784)]
    testData.columns = columns
    FGSMUntargeted = fgsmun(model, testData[2500:2600])
    FGSMTargeted = fgsmtar(model, testData[2600:2700])
    DeepFoolUntargeted = dfun(model, testData[2700:2800])
    DeepFoolTargeted = dftar(model, testData[2800:2900])
    CarliniWagnerTargeted = cnwtar(model, testData[2900:3000])
    randUntargeted = randun(model, testData[3000:3100])
    testDataFin = pd.concat([testData[:2500],FGSMUntargeted, FGSMTargeted, DeepFoolUntargeted, DeepFoolTargeted, CarliniWagnerTargeted, randUntargeted])
    idk = testClass(classifier1, testData)
    idk = testClass(classifier2, testData)
        





if __name__ == '__main__':
    main()